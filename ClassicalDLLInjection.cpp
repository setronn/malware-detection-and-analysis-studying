#include <windows.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <stdio.h>

DWORD GetProcessIDByName(WCHAR targetProcessName[])
{
    HANDLE hProcessSnap;
    HANDLE hProcess;
    PROCESSENTRY32 pe32;

    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    pe32.dwSize = sizeof(PROCESSENTRY32);

    while (Process32Next(hProcessSnap, &pe32) ) 
    {
        if (wcsstr(pe32.szExeFile, targetProcessName) != 0) {
            return pe32.th32ProcessID;
        }
    }
    printf("Error: the specified by the name process couldn't be found.\n");
    return -1;
    CloseHandle(hProcessSnap);
}

void injectDLL(DWORD targetProcessID, const char dllPath[]) {
    LPVOID addr = (LPVOID)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryA");
    if (addr == NULL) {
        printf("Error: the LoadLibraryA function was not found inside kernel32.dll library.\n");
    }

    HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetProcessID);
    if (hProc == NULL) {
        printf("Error: the specified by the ID process couldn't be found.\n");
    }

    LPVOID arg = (LPVOID)VirtualAllocEx(hProc, NULL, strlen(dllPath), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (arg == NULL) {
        printf("Error: the memory could not be allocated inside the chosen process.\n");
    }

    int n = WriteProcessMemory(hProc, arg, dllPath, strlen(dllPath), NULL);
    if (n == 0) {
        printf("Error: there was no bytes written to the process's address space.\n");
    }

    HANDLE threadID = CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)addr, arg, NULL, NULL);
    if (threadID == NULL) {
        printf("Error: the remote thread could not be created.\n");
    }
    else {
        printf("Success: the remote thread was successfully created.\n");
    }
}

int _tmain()
{
    const char dllPath[] = "C:\\injected.dll";
    WCHAR targetProcessName[] = L"notepad.exe";
    DWORD pid = GetProcessIDByName(targetProcessName);
    injectDLL(pid, dllPath);
    
    getchar();
}
